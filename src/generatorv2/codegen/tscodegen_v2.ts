import { generateEntityFile } from './ts/generateEntity.js';
import { EntityNode } from '../nodes/entityNode.js';
import { RootNode } from '../nodes/rootNode.js';
import { generateTypeDefs } from './ts/generateTypeDefs.js';
import { generateQueryResolver } from './ts/generateQueryResolver.js';
import { generateMutationResolver } from './ts/generateMutationResolver.js';
import { generateRelationMap } from './ts/relationMap/index.js';
import { generateFields } from './ts/generateFields.js';
import { generateAutoGeneratedDatasource } from './ts/generateAutoGeneratedDatasource.js';
import { staticFiles } from './ts/staticFiles.js';
import { generateDatasource } from './ts/generateDatasource.js';
import { generateResolver } from './ts/generateResolver.js';
import { generateContext } from './ts/generateContext.js';
import { generateSubscription } from './ts/generateSubscription.js';
import { generateUserDefinedCondition } from './ts/generateUserDefinedCondition.js';
import { generateIDEncoder } from './ts/generateIDEncoder.js';
import { generateMiddlewares } from './ts/generateMiddlewares.js';

export type FileData = { name: string; body: string };

export class TsCodegen_v2 {
  readonly fileExtension = 'ts';
  generateEntity = (node: EntityNode) => generateEntityFile(node).generate();
  generateDatasource = (node: EntityNode) =>
    generateDatasource(node).generate();
  generateGeneratedDatasource = (node: EntityNode) =>
    generateAutoGeneratedDatasource(node).generate();
  generateGqlTypeDefs = (root: RootNode) => generateTypeDefs(root).generate();
  generateGqlResolver = (root: RootNode) => generateResolver(root).generate();
  generateGqlQuery = (root: RootNode) => generateQueryResolver(root).generate();
  generateGqlMutation = (root: RootNode) =>
    generateMutationResolver(root).generate();
  generateGqlSubscription = (root: RootNode) =>
    generateSubscription(root).generate();
  generateGQLContext = (root: RootNode) => generateContext(root).generate();
  generateFiles = async (root: RootNode): Promise<FileData[]> => {
    return [
      {
        name: 'relationMap',
        body: await generateRelationMap(root).generate(),
      },
      { name: 'fields', body: await generateFields(root).generate() },
    ];
  };
  generateOnceFiles = (): FileData[] => {
    return staticFiles;
  };
  generateConditions = (root: RootNode, currentFile: string): string | null => {
    return generateUserDefinedCondition(root, currentFile);
  };
  generateIDEncoders = (root: RootNode, currentFile: string): string | null => {
    return generateIDEncoder(root, currentFile);
  };
  generateMiddlewares = (
    root: RootNode,
    currentFile: string,
  ): string | null => {
    return generateMiddlewares(root, currentFile);
  };
}
